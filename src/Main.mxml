<?xml version="1.0"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"
               xmlns:s="library://ns.adobe.com/flex/spark"
               width="100%"
               height="100%"
               frameRate="60"
               applicationComplete="onApplicationComplete(event)">

    <fx:Script>
        <![CDATA[
        import global.Color;
        import global.Direction;
        import global.Util;

        import graph.Cell;
        import graph.Corner;
        import graph.Edge;

        import layers.moisture.Gust;

        import mx.core.UIComponent;
        import mx.events.FlexEvent;

        public static var map:Map;

        private var seed:int = 1;

        private var layerDebug:UIComponent;
        private var layerOutlines:UIComponent;
        private var layerTectonicPlates:UIComponent;
        private var layerHeightMap:UIComponent;
        private var layerContinents:UIComponent;
        private var layerRelief:UIComponent;
        private var layerOcean:UIComponent;
        private var layerWind:UIComponent;

        public function onApplicationComplete(event:FlexEvent):void {
            setTimeout(function ():void {
                NativeApplication.nativeApplication.activeWindow.maximize();
                setTimeout(onMaximized, 100);
            }, 200);
        }

        public function onMaximized():void {
            // Set up layers
            layerOutlines = new UIComponent();
            layerTectonicPlates = new UIComponent();
            layerHeightMap = new UIComponent();
            layerContinents = new UIComponent();
            layerRelief = new UIComponent();
            layerOcean = new UIComponent();
            layerWind = new UIComponent();
            layerDebug = new UIComponent();

            var drawLayers:Array = [layerTectonicPlates, layerHeightMap, layerContinents, layerRelief, layerOcean, layerWind, layerOutlines, layerDebug];
            for each (var layer:UIComponent in drawLayers)
                addElement(layer);

            // Initial layers
            var initialLayers:Array = [layerWind, layerDebug];
            //var initialLayers:Array = [layerWind, layerContinents, layerOcean, layerRelief, layerOutlines, layerDebug];
            for each (layer in drawLayers)
                layer.visible = false;
            for each (layer in initialLayers)
                layer.visible = true;

            // Make Map
            makeMap();
            draw();

            // Center
            for each (layer in drawLayers) {
                layer.x = (width - map.width) / 2;
                layer.y = (height - map.height) / 2;
            }

            // Interactivity
            stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);
            addEventListener(MouseEvent.CLICK, onClick);
        }

        private function draw():void {
            drawOutlines();
            drawTectonicPlates();
            drawColorHeightMap();
            drawContinents();
            drawRelief();
            drawOcean();
            drawWind();

            var t:Timer = new Timer(100);
            t.addEventListener(TimerEvent.TIMER, function (e:TimerEvent):void {
                drawWind();
            });
            t.start();
        }

        private function onKeyDown(event:KeyboardEvent):void {
            switch (event.keyCode) {
                case Keyboard.SPACE:
                    toggleLayer(layerDebug);
                    break;
                case Keyboard.ENTER:
                    makeMap();
                    draw();
                    break;
                case Keyboard.Q:
                    toggleLayer(layerOutlines);
                    break;
                case Keyboard.W:
                    toggleLayer(layerRelief);
                    break;
                case Keyboard.E:
                    toggleLayer(layerContinents);
                    break;
                case Keyboard.R:
                    toggleLayer(layerOcean);
                    break;
                case Keyboard.T:
                    toggleLayer(layerHeightMap);
                    break;
                case Keyboard.Y:
                    toggleLayer(layerTectonicPlates);
                    break;
                case Keyboard.U:
                    toggleLayer(layerWind);
                    break;
                default:
                    break;
            }
        }

        private function toggleLayer(layer:UIComponent):void {
            layer.visible = !layer.visible;
        }

        private function onClick(event:MouseEvent):void {
            var p:Point = new Point(event.localX, event.localY);
            map.wind.reset();

            var w:Gust = map.wind.closestHexToPoint(p);
            w.angle = Direction.SOUTH;
            w.strength = 30;

            map.wind.propagate([w]);
        }

        private function makeMap():void {
            var d:Date = new Date();
            map = new Map(1200, 600, seed++);
            Util.log("Total time taken: " + "  " + Util.secondsSince(d));
        }

        private function drawContinents():void {
            var g:Graphics = layerContinents.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                if (!cell.ocean)
                    fillCell(g, cell, Color.green);
        }

        private function drawOcean():void {
            var g:Graphics = layerOcean.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                if (cell.ocean)
                    fillCell(g, cell, Color.blue, .6);
        }

        private function drawWind():void {
            var g:Graphics = layerWind.graphics;
            g.clear();

            while (layerWind.numChildren > 0)
                layerWind.removeChildAt(0);

            for each (var hex:Gust in map.wind.hexes) {
                g.lineStyle(1,
                        0x000000);
                //g.beginFill(Util.colorBetweenColors(Color.black, Color.red, hex.height));
                g.beginFill(hex.strength > 0 ? Color.blue : Color.darkBlue);
                g.moveTo(hex.corners[hex.corners.length - 1].x,
                        hex.corners[hex.corners.length - 1].y);
                for (var i:int = 0; i < hex.corners.length; i++) {
                    var corner:Point = hex.corners[i];
                    g.lineTo(corner.x,
                            corner.y);
                }

                var txt:TextField = new TextField();
                layerWind.addChild(txt);
                txt.autoSize = TextFieldAutoSize.CENTER;
                txt.width = txt.textWidth + 5;
                txt.textColor = Color.green;
                var f:TextFormat = new TextFormat();
                f.align = TextFormatAlign.CENTER;
                txt.defaultTextFormat = f;
                txt.text = hex.index + "\n" + hex.strength.toFixed(2);
                txt.x = hex.point.x - txt.width / 2;
                txt.y = hex.point.y - txt.height - 10;
                txt.visible = hex.index >= 0;

                drawPointer(g, hex.point, hex.angle, Color.white, Math.max(hex.strength, 10));
                g.endFill();
            }
        }


        private function drawRelief():void {
            var g:Graphics = layerRelief.graphics;
            g.clear();

            for each (var cell:Cell in map.cells) {
                // Create triangles
                for each (var edge:Edge in cell.edges) {
                    g.beginFill(Color.black, calculateLighting(cell, edge.v0, edge.v1) * .8);
                    g.moveTo(cell.point.x, cell.point.y);
                    g.lineTo(edge.v0.point.x, edge.v0.point.y);
                    g.lineTo(edge.v1.point.x, edge.v1.point.y);
                    g.endFill();
                }
            }
        }

        public function calculateLighting(p:Cell, r:Corner, s:Corner):Number {
            var lightVector:Vector3D = new Vector3D(1, 1, 0);
            var a:Vector3D = new Vector3D(p.point.x, p.point.y, p.height);
            var b:Vector3D = new Vector3D(r.point.x, r.point.y, r.height);
            var c:Vector3D = new Vector3D(s.point.x, s.point.y, s.height);

            var normal:Vector3D = b.subtract(a).crossProduct(c.subtract(a));
            if (normal.z < 0)
                normal.scaleBy(-1);
            normal.normalize();

            var light:Number = 0.5 + 35 * normal.dotProduct(lightVector);
            if (light < 0) light = 0;
            else if (light > 1) light = 1;

            return light;
        }

        private function drawColorHeightMap():void {
            var g:Graphics = layerHeightMap.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                fillCell(g, cell, colorFromHeightMap(cell.height));
        }

        private function colorFromHeightMap(height:Number):uint {
            var colors:Array = [Color.darkBlue, Color.blue, Color.green, Color.yellow, Color.orange, Color.red];

            var preciseIndex:Number = (colors.length - 1) * height;
            var index:int = Math.floor(preciseIndex);

            var color:uint = colors[index];
            if (index < colors.length - 1)
                color = Util.colorBetweenColors(colors[index], colors[index + 1], preciseIndex - index);

            return color;
        }

        private function drawOutlines():void {
            var g:Graphics = layerOutlines.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                for each (var edge:Edge in cell.edges)
                    if (edge.v0 && edge.v1)
                        drawLine(g, edge.v0.point, edge.v1.point, Color.black);
        }

        private function drawTectonicPlates():void {
            var g:Graphics = layerTectonicPlates.graphics;
            g.clear();

            for each (var cell:Cell in map.cells) {
                if (cell.tectonicPlate)
                    fillCell(g, cell, cell.tectonicPlate.color);

                // Draw tectonic plate direction
                if (cell.tectonicPlateBorder)
                    drawPointer(g, cell.point, cell.tectonicPlateDirection, Color.black);
            }
        }

        private function fillCell(g:Graphics, cell:Cell, color:uint, alpha:Number = 1):void {
            // Draw a filled cell
            g.beginFill(color, alpha);
            for each (var edge:Edge in cell.edges) {
                if (edge.v0 && edge.v1) {
                    g.moveTo(edge.v0.point.x, edge.v0.point.y);
                    g.lineTo(cell.point.x, cell.point.y);
                    g.lineTo(edge.v1.point.x, edge.v1.point.y);
                }
            }
            g.endFill();
        }

        private function drawDot(g:Graphics, point:Point, color:uint, size:int):void {
            g.beginFill(color);
            g.drawCircle(point.x, point.y, size);
            g.endFill();
        }

        private function drawLine(g:Graphics, point1:Point, point2:Point, color:uint, weight:Number = 1):void {
            g.lineStyle(weight, color);
            g.moveTo(point1.x, point1.y);
            g.lineTo(point2.x, point2.y);
            g.lineStyle();
        }

        private function drawPointer(g:Graphics, point:Point, direction:Number, color:uint, distance:Number = 7):void {
            // Draw pointer
            g.lineStyle(2, color);
            g.beginFill(color);
            g.drawCircle(point.x, point.y, 2);
            g.endFill();
            g.moveTo(point.x, point.y);
            var head:Point = Util.pointFromDegreesAndDistance(point, direction, distance);
            g.lineTo(head.x, head.y);
            g.lineStyle();
        }
        ]]>
    </fx:Script>
</s:Application>