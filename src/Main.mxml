<?xml version="1.0"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"
               xmlns:s="library://ns.adobe.com/flex/spark" xmlns:ui="ui.*"
               width="100%"
               height="100%"
               frameRate="60"
               preinitialize="onPreinitialize(event)"
               applicationComplete="onApplicationComplete(event)"
               resize="onResize(event)">

    <fx:Style source="/css/global.css" />

    <fx:Script>
        <![CDATA[
        import global.Color;
        import global.Sort;
        import global.Util;

        import graph.Cell;
        import graph.Corner;
        import graph.Edge;

        import layers.geography.River;
        import layers.wind.Gust;

        import mx.core.UIComponent;
        import mx.events.FlexEvent;

        public static var map:Map;

        private var seed:int = 1;

        private var layerDebug:UIComponent;
        private var layerOutlines:UIComponent;
        private var layerTectonicPlates:UIComponent;
        private var layerHeightMap:UIComponent;
        private var layerContinents:UIComponent;
        private var layerRelief:UIComponent;
        private var layerOcean:UIComponent;
        private var layerWind:UIComponent;
        private var layerPrecipitation:UIComponent;
        private var layerTemperature:UIComponent;
        private var layerWater:UIComponent;
        private var layerFlux:UIComponent;
        private var layerRivers:UIComponent;

        private var layers:Array;

        public function onPreinitialize(event:FlexEvent):void {
            //NativeApplication.nativeApplication.activeWindow.maximize();
        }

        public function onApplicationComplete(event:FlexEvent):void {
            // Set up layers
            layerDebug = new UIComponent();
            layerDebug.name = "debug";
            layerOutlines = new UIComponent();
            layerOutlines.name = "outlines";
            layerTectonicPlates = new UIComponent();
            layerTectonicPlates.name = "tectonics";
            layerHeightMap = new UIComponent();
            layerHeightMap.name = "elevation";
            layerContinents = new UIComponent();
            layerContinents.name = "continents";
            layerRelief = new UIComponent();
            layerRelief.name = "relief";
            layerOcean = new UIComponent();
            layerOcean.name = "ocean";
            layerWind = new UIComponent();
            layerWind.name = "wind";
            layerPrecipitation = new UIComponent();
            layerPrecipitation.name = "precipitation";
            layerTemperature = new UIComponent();
            layerTemperature.name = "temperature";
            layerWater = new UIComponent();
            layerWater.name = "water";
            layerFlux = new UIComponent();
            layerFlux.name = "flux";
            layerRivers = new UIComponent();
            layerRivers.name = "rivers";

            layers = [layerTectonicPlates, layerHeightMap, layerContinents, layerRelief, layerOcean, layerWind, layerWater, layerPrecipitation, layerFlux, layerRivers, layerTemperature, layerOutlines, layerDebug];
            for each (var layer:UIComponent in layers)
                addElement(layer);

            // Initial layers
            var initialLayers:Array = [layerTectonicPlates];
            for each (layer in layers)
                layer.visible = false;
            for each (layer in initialLayers)
                layer.visible = true;


            // Make Map
            makeMap();
            draw();
            center();

            // Interactivity
            userInterface.addLayers(layers.reverse());

            stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);
            addEventListener(MouseEvent.CLICK, onClick);
        }

        public function onResize(event:Event):void {
            center();
        }

        private function center():void {
            // Center
            for each (var layer:UIComponent in layers) {
                layer.x = (width - map.width) / 2;
                layer.y = (height - map.height) / 2;
            }
        }

        private function draw():void {
            drawOutlines();
            drawTectonicPlates();
            drawColorHeightMap();
            drawContinents();
            drawRelief();
            drawOcean();

            //drawWind();
            //drawPrecipitation();
            //drawTemperature();
            //drawWater();
            //drawFlux();
            //drawRivers();
        }

        private function onKeyDown(event:KeyboardEvent):void {
            switch (event.keyCode) {
                case Keyboard.SPACE:
                    toggleLayer(layerDebug);
                    break;
                case Keyboard.NUMBER_1:
                    map.hydrology.precipitate();
                    draw();
                    break;
                case Keyboard.NUMBER_2:
                    map.hydrology.distributeWater();
                    map.setCornerHeights();
                    draw();
                    break;
                case Keyboard.NUMBER_3:
                    map.hydrology.sequence();
                    draw();
                    break;
                case Keyboard.ENTER:
                    makeMap();
                    draw();
                    break;
                case Keyboard.Q:
                    toggleLayer(layerOutlines);
                    break;
                case Keyboard.W:
                    toggleLayer(layerRelief);
                    break;
                case Keyboard.E:
                    toggleLayer(layerContinents);
                    break;
                case Keyboard.R:
                    toggleLayer(layerOcean);
                    break;
                case Keyboard.T:
                    toggleLayer(layerHeightMap);
                    break;
                case Keyboard.Y:
                    toggleLayer(layerTectonicPlates);
                    break;
                case Keyboard.U:
                    toggleLayer(layerWind);
                    break;
                case Keyboard.I:
                    toggleLayer(layerPrecipitation);
                    break;
                case Keyboard.O:
                    toggleLayer(layerTemperature);
                    break;
                case Keyboard.P:
                    toggleLayer(layerWater);
                    break;
                case Keyboard.A:
                    toggleLayer(layerFlux);
                    break;
                case Keyboard.S:
                    toggleLayer(layerRivers);
                    break;
                default:
                    break;
            }
        }

        private function toggleLayer(layer:UIComponent):void {
            layer.visible = !layer.visible;
            var onOrOff:String = layer.visible ? "ON" : "OFF";
            Util.log(Util.capitalizeFirstLetter(layer.name) + " [" + onOrOff + "]");
            userInterface.updateItem(layer);
        }

        private function onClick(event:MouseEvent):void {
            var p:Point = new Point(event.localX, event.localY);
            var arr:Array = Util.toArray(map.quadTree.queryFromPoint(p, 10));
            if (arr.length > 0) {
                var t:Point = Util.closestPoint(p, arr);
                var c:Cell = map.getCellByPoint(t);
                describe(c);
//                c.water += 1;
//                draw();
            }
        }

        private function describe(c:Cell):void {
            trace("Cell #" + c.index);
            trace("  altitude=" + c.altitude);
            trace("  elevation=" + c.elevation + ", water=" + c.water);
            var n:Number = 0;
            for (var i:String in c.outflows) {
                n += c.outflows[i].water;
                trace("Outflow from #" + i + ": " + c.outflows[i]);
            }
            trace("Total water: " + n + " (=" + c.water + "?)");
            var neighborIndexes:Array = [];
            for each (var neighbor:Cell in c.neighbors)
                neighborIndexes.push(neighbor.index);
            trace("Neighbors (" + c.neighbors.length + "): " + neighborIndexes.join(", "));
        }

        private function makeMap():void {
            var d:Date = new Date();
            map = new Map(1200, 600, seed++);
            Util.log("Total time taken: " + "  " + Util.secondsSince(d));
        }

        private function drawContinents():void {
            var g:Graphics = layerContinents.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                if (!cell.ocean)
                    fillCell(g, cell, Color.green);
        }

        private function drawOcean():void {
            var g:Graphics = layerOcean.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                if (cell.ocean)
                    fillCell(g, cell, Color.blue, .6);
        }

        private function drawWind():void {
            var g:Graphics = layerWind.graphics;
            g.clear();

            for each (var gust:Gust in map.wind.gusts)
                if (gust.strength > 0)
                    drawPointer(g, gust.point, gust.angle, Color.white, 5, gust.strength / 30);
        }

        private function drawPrecipitation():void {
            var g:Graphics = layerPrecipitation.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                fillCell(g, cell, Color.darkBlue, cell.precipitation);
        }

        private function drawTemperature():void {
            var g:Graphics = layerTemperature.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                fillCell(g, cell, Util.colorBetweenColors(Color.blue, Color.orange, cell.temperature), .7);
        }

        private function drawFlux():void {
            var g:Graphics = layerFlux.graphics;
            g.clear();
            g.lineStyle(1, Color.darkBlue);

            for each (var cell:Cell in map.cells) {
                if (cell.lowestNeighbor && !cell.lowestNeighbor.ocean) {
                    g.moveTo(cell.point.x, cell.point.y);
                    g.lineTo(cell.lowestNeighbor.point.x, cell.lowestNeighbor.point.y);
                }
            }
        }

        private function drawRivers():void {
            var g:Graphics = layerRivers.graphics;
            g.clear();

            map.hydrology.rivers.sort(Sort.riverByLength);
            for each (var river:River in map.hydrology.rivers) {
                g.lineStyle(1, Math.random() * 0xffffff);
                var color:uint = Color.random;
                for each (var cell:Cell in river.cells) {
                    if (river.end != cell) {
                        drawPointer(g, cell.point, Util.angleBetweenTwoPoints(cell.point, cell.lowestNeighbor.point), color);
                    } else {
                        drawDot(g, cell.point, color, 5);
                    }
                }
            }
        }

        private function drawWater():void {
            var g:Graphics = layerWater.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                if (cell.water > 0.1)
                    fillCell(g, cell, Color.blue, cell.water * 2);
        }

        private function drawRelief():void {
            var g:Graphics = layerRelief.graphics;
            g.clear();

            for each (var cell:Cell in map.cells) {
                // Create triangles
                for each (var edge:Edge in cell.edges) {
                    if (!edge.v0 || !edge.v1)
                        continue;

                    g.beginFill(Color.black, calculateLighting(cell, edge.v0, edge.v1) * .8);
                    g.moveTo(cell.point.x, cell.point.y);
                    g.lineTo(edge.v0.point.x, edge.v0.point.y);
                    g.lineTo(edge.v1.point.x, edge.v1.point.y);
                    g.endFill();
                }
            }
        }

        public function calculateLighting(p:Cell, r:Corner, s:Corner):Number {
            if (!p || !r || !s)
                return 0;

            var lightVector:Vector3D = new Vector3D(1, 1, 0);

            var a:Vector3D = new Vector3D(p.point.x, p.point.y, p.elevation);
            var b:Vector3D = new Vector3D(r.point.x, r.point.y, r.elevation);
            var c:Vector3D = new Vector3D(s.point.x, s.point.y, s.elevation);

            var normal:Vector3D = b.subtract(a).crossProduct(c.subtract(a));
            if (normal.z < 0)
                normal.scaleBy(-1);
            normal.normalize();

            var light:Number = 0.5 + 35 * normal.dotProduct(lightVector);
            if (light < 0) light = 0;
            else if (light > 1) light = 1;

            return light;
        }

        private function drawColorHeightMap():void {
            var g:Graphics = layerHeightMap.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                fillCell(g, cell, colorFromHeightMap(cell.elevation));
        }

        private function colorFromHeightMap(height:Number):uint {
            var colors:Array = [Color.darkBlue, Color.blue, Color.green, Color.yellow, Color.orange, Color.red];

            var preciseIndex:Number = (colors.length - 1) * height;
            var index:int = Math.floor(preciseIndex);

            var color:uint = colors[index];
            if (index < colors.length - 1)
                color = Util.colorBetweenColors(colors[index], colors[index + 1], preciseIndex - index);

            return color;
        }

        private function drawOutlines():void {
            var g:Graphics = layerOutlines.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                for each (var edge:Edge in cell.edges)
                    if (edge.v0 && edge.v1)
                        drawLine(g, edge.v0.point, edge.v1.point, Color.black);
        }

        private function drawTectonicPlates():void {
            var g:Graphics = layerTectonicPlates.graphics;
            g.clear();

            for each (var cell:Cell in map.cells) {
                if (cell.tectonicPlate)
                    fillCell(g, cell, cell.tectonicPlate.color);

                // Draw tectonic plate direction
                if (cell.tectonicPlateBorder)
                    drawPointer(g, cell.point, cell.tectonicPlateDirection, Color.black);
            }
        }

        private function fillCell(g:Graphics, cell:Cell, color:uint, alpha:Number = 1):void {
            // Draw a filled cell
            g.beginFill(color, alpha);
            for each (var edge:Edge in cell.edges) {
                if (edge.v0 && edge.v1) {
                    g.moveTo(edge.v0.point.x, edge.v0.point.y);
                    g.lineTo(cell.point.x, cell.point.y);
                    g.lineTo(edge.v1.point.x, edge.v1.point.y);
                }
            }
            g.endFill();
        }

        private function drawDot(g:Graphics, point:Point, color:uint, size:int):void {
            g.beginFill(color);
            g.drawCircle(point.x, point.y, size);
            g.endFill();
        }

        private function drawLine(g:Graphics, point1:Point, point2:Point, color:uint, weight:Number = 1):void {
            g.lineStyle(weight, color);
            g.moveTo(point1.x, point1.y);
            g.lineTo(point2.x, point2.y);
            g.lineStyle();
        }

        private function drawPointer(g:Graphics, point:Point, direction:Number, color:uint, distance:Number = 7, pointerAlpha:Number = 1):void {
            // Draw pointer
            g.lineStyle(2, color, pointerAlpha);
            g.beginFill(color, pointerAlpha);
            g.drawCircle(point.x, point.y, 2);
            g.endFill();
            g.moveTo(point.x, point.y);
            var head:Point = Util.pointFromDegreesAndDistance(point, direction, distance);
            g.lineTo(head.x, head.y);
            g.lineStyle();
        }
        ]]>
    </fx:Script>
    <s:Group width="100%" height="100%">
        <s:Group id="layerGroup" width="100%" height="100%" />
        <s:VGroup width="100%" padding="10">
            <s:Label text="Layers" />
            <ui:UserInterface id="userInterface" width="100%" height="100%" />
        </s:VGroup>
    </s:Group>
</s:Application>