<?xml version="1.0"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"
               xmlns:s="library://ns.adobe.com/flex/spark"
               xmlns:ui="ui.*"
               width="100%"
               height="100%"
               frameRate="60"
               applicationComplete="onApplicationComplete(event)">

    <fx:Style source="/assets/css/global.css" />

    <fx:Script>
        <![CDATA[
        import global.Color;
        import global.Sort;
        import global.Util;
        import global.performance.PerformanceReport;
        import global.performance.PerformanceReport;
        import global.performance.PerformanceReportItem;

        import graph.Cell;
        import graph.Corner;
        import graph.Edge;

        import layers.geography.River;
        import layers.wind.Gust;

        import mx.core.UIComponent;
        import mx.events.FlexEvent;
        import mx.events.ResizeEvent;

        import ui.UIEventType;

        public static var map:Map;

        private var seed:int = 0;

        private var layerDebug:UIComponent;
        private var layerOutlines:UIComponent;
        private var layerTectonicPlates:UIComponent;
        private var layerHeightMap:UIComponent;
        private var layerContinents:UIComponent;
        private var layerRelief:UIComponent;
        private var layerOcean:UIComponent;
        private var layerWind:UIComponent;
        private var layerPrecipitation:UIComponent;
        private var layerTemperature:UIComponent;
        private var layerWater:UIComponent;
        private var layerFlux:UIComponent;
        private var layerRivers:UIComponent;

        private var layers:Array;

        public function onApplicationComplete(event:FlexEvent):void {
            // Set up layers
            layerDebug = new UIComponent();
            layerDebug.name = "debug";
            layerOutlines = new UIComponent();
            layerOutlines.name = "outlines";
            layerTectonicPlates = new UIComponent();
            layerTectonicPlates.name = "tectonics";
            layerHeightMap = new UIComponent();
            layerHeightMap.name = "elevation";
            layerContinents = new UIComponent();
            layerContinents.name = "continents";
            layerRelief = new UIComponent();
            layerRelief.name = "relief";
            layerOcean = new UIComponent();
            layerOcean.name = "ocean";
            layerWind = new UIComponent();
            layerWind.name = "wind";
            layerPrecipitation = new UIComponent();
            layerPrecipitation.name = "precipitation";
            layerTemperature = new UIComponent();
            layerTemperature.name = "temperature";
            layerWater = new UIComponent();
            layerWater.name = "water";
            layerFlux = new UIComponent();
            layerFlux.name = "flux";
            layerRivers = new UIComponent();
            layerRivers.name = "rivers";

            //layers = [layerTectonicPlates, layerHeightMap, layerContinents, layerRelief, layerOcean, layerWind, layerWater, layerPrecipitation, layerFlux, layerRivers, layerTemperature, layerOutlines, layerDebug];
            layers = [layerTectonicPlates, layerHeightMap, layerContinents, layerRelief, layerOcean, layerOutlines, layerDebug];
            for each (var layer:UIComponent in layers) {
                layerGroup.addElement(layer);
            }

            // Initial layers
            var initialLayers:Array = [layerHeightMap, layerContinents, layerRelief, layerOcean];
            for each (layer in layers)
                layer.visible = false;
            for each (layer in initialLayers)
                layer.visible = true;


            // Make Map
            makeMap();
            draw();

            // Interactivity
            userInterface.addLayers(layers.reverse());

            addEventListener(MouseEvent.CLICK, onClick);

            userInterface.addEventListener(UIEventType.MAKE_MAP, function (event:Event):void {
                userInterface.setToWorking();
                setTimeout(function ():void {
                    makeMap();
                    draw();
                }, 100);
            });
        }

        private function draw():void {
            drawDebug();
            drawOutlines();
            drawTectonicPlates();
            drawColorHeightMap();
            drawContinents();
            drawRelief();
            drawOcean();

            //drawWind();
            //drawPrecipitation();
            //drawTemperature();
            //drawWater();
            //drawFlux();
            //drawRivers();
        }

        private function toggleLayer(layer:UIComponent):void {
            layer.visible = !layer.visible;
            var onOrOff:String = layer.visible ? "ON" : "OFF";
            Util.log(Util.capitalizeFirstLetter(layer.name) + " [" + onOrOff + "]");
            userInterface.updateLayer(layer);
        }

        private function onClick(event:MouseEvent):void {
            return;
            var p:Point = new Point(event.localX, event.localY);
            var arr:Array = Util.toArray(map.quadTree.queryFromPoint(p, 10));
            if (arr.length > 0) {
                var t:Point = Util.closestPoint(p, arr);
                var c:Cell = map.getCellByPoint(t);
                describe(c);
//                c.water += 1;
//                draw();
            }
        }

        private function describe(c:Cell):void {
            trace("Cell #" + c.index);
            trace("  altitude=" + c.altitude);
            trace("  elevation=" + c.elevation + ", water=" + c.water);
            var n:Number = 0;
            for (var i:String in c.outflows) {
                n += c.outflows[i].water;
                trace("Outflow from #" + i + ": " + c.outflows[i]);
            }
            trace("Total water: " + n + " (=" + c.water + "?)");
            var neighborIndexes:Array = [];
            for each (var neighbor:Cell in c.neighbors)
                neighborIndexes.push(neighbor.index);
            trace("Neighbors (" + c.neighbors.length + "): " + neighborIndexes.join(", "));
        }

        private function makeMap():void {
            var d:Date = new Date();
            map = new Map(1200, 600, seed);
            Util.log("#### Seed " + seed + " complete! ####");
            Util.log("Total time taken: " + "  " + Util.secondsSince(d));

            PerformanceReport.items.sortOn("timeTakenInSeconds", Array.DESCENDING);

//            for each (var item:PerformanceReportItem in PerformanceReport.items) {
//                var p:Number = item.percent * 100;
//                var pString:String = p < 1 ? p.toFixed(2) : p.toFixed(0);
//                Util.log(item.name + ": " + item.timeTakenInSeconds + " seconds -- " + pString + "%");
//            }

            userInterface.setToReady();
            userInterface.updateSeed(seed);

            seed++;
        }

        private function drawContinents():void {
            var g:Graphics = layerContinents.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                if (!cell.ocean)
                    fillCell(g, cell, Color.green);
        }

        private function drawOcean():void {
            var g:Graphics = layerOcean.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                if (cell.ocean)
                    fillCell(g, cell, Color.blue, .6);
        }

        private function drawWind():void {
            var g:Graphics = layerWind.graphics;
            g.clear();

            for each (var gust:Gust in map.wind.gusts)
                if (gust.strength > 0)
                    drawPointer(g, gust.point, gust.angle, Color.white, 5, gust.strength / 30);
        }

        private function drawPrecipitation():void {
            var g:Graphics = layerPrecipitation.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                fillCell(g, cell, Color.darkBlue, cell.precipitation);
        }

        private function drawTemperature():void {
            var g:Graphics = layerTemperature.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                fillCell(g, cell, Util.colorBetweenColors(Color.blue, Color.orange, cell.temperature), .7);
        }

        private function drawFlux():void {
            var g:Graphics = layerFlux.graphics;
            g.clear();
            g.lineStyle(1, Color.darkBlue);

            for each (var cell:Cell in map.cells) {
                if (cell.lowestNeighbor && !cell.lowestNeighbor.ocean) {
                    g.moveTo(cell.point.x, cell.point.y);
                    g.lineTo(cell.lowestNeighbor.point.x, cell.lowestNeighbor.point.y);
                }
            }
        }

        private function drawRivers():void {
            var g:Graphics = layerRivers.graphics;
            g.clear();

            map.hydrology.rivers.sort(Sort.riverByLength);
            for each (var river:River in map.hydrology.rivers) {
                g.lineStyle(1, Math.random() * 0xffffff);
                var color:uint = Color.random;
                for each (var cell:Cell in river.cells) {
                    if (river.end != cell) {
                        drawPointer(g, cell.point, Util.angleBetweenTwoPoints(cell.point, cell.lowestNeighbor.point), color);
                    } else {
                        drawDot(g, cell.point, color, 5);
                    }
                }
            }
        }

        private function drawWater():void {
            var g:Graphics = layerWater.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                if (cell.water > 0.1)
                    fillCell(g, cell, Color.blue, cell.water * 2);
        }

        private function drawRelief():void {
            var g:Graphics = layerRelief.graphics;
            g.clear();

            for each (var cell:Cell in map.cells) {
                // Create triangles
                for each (var edge:Edge in cell.edges) {
                    if (!edge.v0 || !edge.v1)
                        continue;

                    g.beginFill(Color.black, calculateLighting(cell, edge.v0, edge.v1) * .8);
                    g.moveTo(cell.point.x, cell.point.y);
                    g.lineTo(edge.v0.point.x, edge.v0.point.y);
                    g.lineTo(edge.v1.point.x, edge.v1.point.y);
                    g.endFill();
                }
            }
        }

        public function calculateLighting(p:Cell, r:Corner, s:Corner):Number {
            if (!p || !r || !s)
                return 0;

            var lightVector:Vector3D = new Vector3D(1, 1, 0);

            var a:Vector3D = new Vector3D(p.point.x, p.point.y, p.elevation);
            var b:Vector3D = new Vector3D(r.point.x, r.point.y, r.elevation);
            var c:Vector3D = new Vector3D(s.point.x, s.point.y, s.elevation);

            var normal:Vector3D = b.subtract(a).crossProduct(c.subtract(a));
            if (normal.z < 0)
                normal.scaleBy(-1);
            normal.normalize();

            var light:Number = 0.5 + 35 * normal.dotProduct(lightVector);
            if (light < 0) light = 0;
            else if (light > 1) light = 1;

            return light;
        }

        private function drawColorHeightMap():void {
            var g:Graphics = layerHeightMap.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                fillCell(g, cell, colorFromHeightMap(cell.elevation));
        }

        private function colorFromHeightMap(height:Number):uint {
            var colors:Array = [Color.darkBlue, Color.blue, Color.green, Color.yellow, Color.orange, Color.red];

            var preciseIndex:Number = (colors.length - 1) * height;
            var index:int = Math.floor(preciseIndex);

            var color:uint = colors[index];
            if (index < colors.length - 1)
                color = Util.colorBetweenColors(colors[index], colors[index + 1], preciseIndex - index);

            return color;
        }

        private function drawDebug():void {
            var g:Graphics = layerDebug.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                drawDot(g, cell.point, Color.orange, 3);
        }

        private function drawOutlines():void {
            var g:Graphics = layerOutlines.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                for each (var edge:Edge in cell.edges)
                    if (edge.v0 && edge.v1)
                        drawLine(g, edge.v0.point, edge.v1.point, Color.black);
        }

        private function drawTectonicPlates():void {
            var g:Graphics = layerTectonicPlates.graphics;
            g.clear();

            for each (var cell:Cell in map.cells) {
                if (cell.tectonicPlate)
                    fillCell(g, cell, cell.tectonicPlate.color);

                // Draw tectonic plate direction
                if (cell.tectonicPlateBorder)
                    drawPointer(g, cell.point, cell.tectonicPlateDirection, Color.black);
            }
        }

        private function fillCell(g:Graphics, cell:Cell, color:uint, alpha:Number = 1):void {
            // Draw a filled cell
            g.beginFill(color, alpha);
            for each (var edge:Edge in cell.edges) {
                if (edge.v0 && edge.v1) {
                    g.moveTo(edge.v0.point.x, edge.v0.point.y);
                    g.lineTo(cell.point.x, cell.point.y);
                    g.lineTo(edge.v1.point.x, edge.v1.point.y);
                }
            }
            g.endFill();
        }

        private function drawDot(g:Graphics, point:Point, color:uint, size:int):void {
            g.beginFill(color);
            g.drawCircle(point.x, point.y, size);
            g.endFill();
        }

        private function drawLine(g:Graphics, point1:Point, point2:Point, color:uint, weight:Number = 1):void {
            g.lineStyle(weight, color);
            g.moveTo(point1.x, point1.y);
            g.lineTo(point2.x, point2.y);
            g.lineStyle();
        }

        private function drawPointer(g:Graphics, point:Point, direction:Number, color:uint, distance:Number = 7, pointerAlpha:Number = 1):void {
            // Draw pointer
            g.lineStyle(2, color, pointerAlpha);
            g.beginFill(color, pointerAlpha);
            g.drawCircle(point.x, point.y, 2);
            g.endFill();
            g.moveTo(point.x, point.y);
            var head:Point = Util.pointFromDegreesAndDistance(point, direction, distance);
            g.lineTo(head.x, head.y);
            g.lineStyle();
        }

        private function onLayerGroupContainerResize(event:ResizeEvent):void {
//            trace(event.target.width, event.target.height);
//            trace(event.target.contentWidth, event.target.contentHeight);

            var t:Object = event.target;
            t.height = (t.width / t.contentWidth) * t.contentHeight;
        }
        ]]>
    </fx:Script>

    <s:VGroup width="100%"
              height="100%"
              gap="0">

        <s:Spacer height="{userInterface.toolBar.height}" />

        <s:Group width="100%"
                 height="100%">

            <s:VGroup id="layerGroupContainer"
                      width="100%"
                      height="100%"
                      mask="{layerGroupMask}"
                      resizeMode="scale"
                      resize="onLayerGroupContainerResize(event)">
                <s:Group id="layerGroup"
                         width="1200"
                         height="600" />
            </s:VGroup>


            <!--            <s:Rect width="100%"-->
            <!--                    height="100%">-->
            <!--                <s:fill>-->
            <!--                    <s:SolidColor color="{Color.red}"-->
            <!--                                  alpha=".4" />-->
            <!--                </s:fill>-->
            <!--            </s:Rect>-->


            <s:HGroup id="layerGroupMask"
                      width="100%"
                      height="{layerGroupContainer.height}"
                      padding="10">
                <s:Rect width="100%"
                        height="100%">
                    <s:fill>
                        <s:SolidColor color="{Color.red}" />
                    </s:fill>
                </s:Rect>
            </s:HGroup>

        </s:Group>

    </s:VGroup>

    <ui:UserInterface id="userInterface"
                      width="100%"
                      height="100%" />

</s:Application>