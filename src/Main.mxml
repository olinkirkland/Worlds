<?xml version="1.0"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"
               xmlns:s="library://ns.adobe.com/flex/spark"
               width="100%"
               height="100%"
               frameRate="60"
               applicationComplete="onApplicationComplete(event)">

    <fx:Script>
        <![CDATA[
        import global.Color;
        import global.Util;

        import graph.Cell;
        import graph.Corner;
        import graph.Edge;

        import layers.TectonicPlate;

        import mx.core.UIComponent;
        import mx.events.FlexEvent;

        import spark.filters.BlurFilter;

        public static var map:Map;

        private var seed:int = 1;

        private var layerOutlines:UIComponent;
        private var layerTectonicPlates:UIComponent;
        private var layerHeightMap:UIComponent;
        private var layerContinents:UIComponent;
        private var layerRelief:UIComponent;
        private var layerOcean:UIComponent;

        public function onApplicationComplete(event:FlexEvent):void {
            setTimeout(function ():void {
                NativeApplication.nativeApplication.activeWindow.maximize();
                setTimeout(makeNewMap, 100);
            }, 100);

            // Set up layers
            layerOutlines = new UIComponent();
            layerTectonicPlates = new UIComponent();
            layerHeightMap = new UIComponent();
            layerContinents = new UIComponent();
            layerRelief = new UIComponent();
            layerOcean = new UIComponent();

            var drawLayers:Array = [layerTectonicPlates, layerHeightMap, layerContinents, layerRelief, layerOcean, layerOutlines];
            for each (var layer:UIComponent in drawLayers)
                addElement(layer);

            // Interactivity
            stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);
            addEventListener(MouseEvent.CLICK, onClick);
        }

        private function draw():void {
            drawOutlines();
            drawTectonicPlates();
            drawColorHeightMap();
            drawContinents();
            drawRelief();
            drawOcean();
        }

        private function onKeyDown(event:KeyboardEvent):void {
            switch (event.keyCode) {
                case Keyboard.N:
                    makeNewMap();
                    break;
                case Keyboard.Q:
                    toggleLayer(layerOutlines);
                    break;
                case Keyboard.W:
                    toggleLayer(layerRelief);
                    break;
                case Keyboard.E:
                    toggleLayer(layerContinents);
                    break;
                case Keyboard.R:
                    toggleLayer(layerOcean);
                    break;
                case Keyboard.T:
                    toggleLayer(layerHeightMap);
                    break;
                case Keyboard.Y:
                    toggleLayer(layerTectonicPlates);
                    break;
                default:
                    break;
            }
        }

        private function toggleLayer(layer:UIComponent):void {
            layer.visible = !layer.visible;
        }

        private function onClick(event:MouseEvent):void {
            var p:Point = new Point(event.localX, event.localY);
            var size:int = 40;
            var range:Rectangle = new Rectangle(p.x - size / 2, p.y - size / 2, size, size);
            var cell:Cell = map.getCellByPoint(Util.closestPoint(p, map.quadTree.query(range)));
            if (!cell)
                return;

            trace("@cell " + cell.index + ", cell.height=" + cell.height);
        }

        private function makeNewMap():void {
            var d:Date = new Date();
            map = new Map(1200, 600, seed++);
            Util.log("Total time taken: " + "  " + Util.secondsSince(d));

            draw();
        }

        private function drawContinents():void {
            var g:Graphics = layerContinents.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                if (!cell.ocean)
                    fillCell(g, cell, Color.green);
        }

        private function drawOcean():void {
            var g:Graphics = layerOcean.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                if (cell.ocean)
                    fillCell(g, cell, Color.blue);
        }


        private function drawRelief():void {
            var g:Graphics = layerRelief.graphics;
            g.clear();

            for each (var cell:Cell in map.cells) {
                // Create triangles
                for each (var edge:Edge in cell.edges) {
                    g.beginFill(Color.black, calculateLighting(cell, edge.v0, edge.v1) * .8);
                    g.moveTo(cell.point.x, cell.point.y);
                    g.lineTo(edge.v0.point.x, edge.v0.point.y);
                    g.lineTo(edge.v1.point.x, edge.v1.point.y);
                    g.endFill();
                }
            }
        }

        public function calculateLighting(p:Cell, r:Corner, s:Corner):Number {
            var lightVector:Vector3D = new Vector3D(-1, -1, 0);
            var A:Vector3D = new Vector3D(p.point.x, p.point.y, p.height);
            var B:Vector3D = new Vector3D(r.point.x, r.point.y, r.height);
            var C:Vector3D = new Vector3D(s.point.x, s.point.y, s.height);
            var normal:Vector3D = B.subtract(A).crossProduct(C.subtract(A));
            if (normal.z < 0)
                normal.scaleBy(-1);
            normal.normalize();
            var light:Number = 0.5 + 35 * normal.dotProduct(lightVector);
            if (light < 0) light = 0;
            if (light > 1) light = 1;
            return light;
        }

        private function drawReliefOld2():void {
            var g:Graphics = layerRelief.graphics;
            g.clear();

            for each (var edge:Edge in map.edges) {
                // Create quad
                var quadPoints:Array = [];
                if (edge.d0 && edge.d1 && edge.v0 && edge.v1) {
                    quadPoints.push(edge.d0.point, edge.v0.point, edge.d1.point, edge.v1.point);

                    // Determine the quad's slope
                    var cell:Cell = map.getCellByPoint(edge.d0.point);
                    var neighbor:Cell = map.getCellByPoint(edge.d1.point);

                    var slope:Number = 200 * (neighbor.height - cell.height) / Util.getDistanceBetweenTwoPoints(cell.point, neighbor.point);
                    slope = Math.abs(slope);

                    // Determine the aspect of the quad (which direction it's facing)
                    var aspect:Number = Util.degreesBetweenTwoPoints(cell.point, neighbor.point);
                    if (aspect < 0) aspect += 360;
                    aspect = (Util.differenceBetweenTwoDegrees(aspect, 235));

                    if (aspect > 140 && slope > .5 && !neighbor.ocean) {
                        g.beginFill(Color.black, .6);
                        g.moveTo(quadPoints[0].x, quadPoints[0].y);
                        for (var i:int = 1; i < quadPoints.length; i++)
                            g.lineTo(quadPoints[i].x, quadPoints[i].y);
                        g.endFill();
                    }
                }
            }
        }

        private function drawColorHeightMap():void {
            var g:Graphics = layerHeightMap.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                fillCell(g, cell, colorFromHeightMap(cell.height));
        }

        private function colorFromHeightMap(height:Number):uint {
            var colors:Array = [Color.darkBlue, Color.blue, Color.green, Color.yellow, Color.orange, Color.red];

            var preciseIndex:Number = (colors.length - 1) * height;
            var index:int = Math.floor(preciseIndex);

            var color:uint = colors[index];
            if (index < colors.length - 1)
                color = Util.colorBetweenColors(colors[index], colors[index + 1], preciseIndex - index);

            return color;
        }

        private function drawOutlines():void {
            var g:Graphics = layerOutlines.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                for each (var edge:Edge in cell.edges)
                    if (edge.v0 && edge.v1)
                        drawLine(g, edge.v0.point, edge.v1.point, Color.black);
        }

        private function drawTectonicPlates():void {
            var g:Graphics = layerTectonicPlates.graphics;
            g.clear();

            for each (var cell:Cell in map.cells) {
                if (cell.tectonicPlate)
                    fillCell(g, cell, cell.tectonicPlate.color);

                // Draw tectonic plate direction
                if (cell.tectonicPlateBorder)
                    drawPointer(g, cell.point, cell.tectonicPlateDirection, Color.black);
            }
        }

        private function fillCell(g:Graphics, cell:Cell, color:uint, alpha:Number = 1):void {
            // Draw a filled cell
            g.beginFill(color, alpha);
            for each (var edge:Edge in cell.edges) {
                if (edge.v0 && edge.v1) {
                    g.moveTo(edge.v0.point.x, edge.v0.point.y);
                    g.lineTo(cell.point.x, cell.point.y);
                    g.lineTo(edge.v1.point.x, edge.v1.point.y);
                }
            }
            g.endFill();
        }

        private function drawDot(g:Graphics, point:Point, color:uint, size:int):void {
            g.beginFill(color);
            g.drawCircle(point.x, point.y, size);
            g.endFill();
        }

        private function drawLine(g:Graphics, point1:Point, point2:Point, color:uint, weight:Number = 1):void {
            g.lineStyle(weight, color);
            g.moveTo(point1.x, point1.y);
            g.lineTo(point2.x, point2.y);
            g.lineStyle();
        }

        private function drawPointer(g:Graphics, point:Point, direction:Number, color:uint):void {
            // Draw pointer
            var head:Point = Util.pointFromAngleAndDistance(point, Util.degreesToRadians(direction), 6);
            g.lineStyle(2, color);
            g.beginFill(Color.white);
            g.drawCircle(point.x, point.y, 4);
            g.endFill();
            g.moveTo(point.x, point.y);
            g.lineTo(head.x, head.y);
            g.lineStyle();
        }
        ]]>
    </fx:Script>
</s:Application>