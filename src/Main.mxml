<?xml version="1.0"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"
               xmlns:s="library://ns.adobe.com/flex/spark"
               width="100%"
               height="100%"
               frameRate="60"
               applicationComplete="onApplicationComplete(event)">

    <fx:Script>
        <![CDATA[
        import graph.Cell;
        import graph.Edge;

        import layers.Lithosphere;
        import layers.TectonicPlate;

        import mx.core.UIComponent;
        import mx.events.FlexEvent;

        import global.Color;
        import global.Util;


        public static var map:Map;
        public static var lithosphere:Lithosphere;
        private var layer0:UIComponent;
        private var layer1:UIComponent;
        private var seed:int = 1;

        public function onApplicationComplete(event:FlexEvent):void {
            NativeApplication.nativeApplication.activeWindow.maximize();
            setTimeout(createNewMap, 100);

            layer0 = new UIComponent();
            addElement(layer0);
            layer1 = new UIComponent();
            addElement(layer1);

            stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);

            addEventListener(MouseEvent.CLICK, onClick);
        }

        private function onKeyDown(event:KeyboardEvent):void {
            switch (event.keyCode) {
                case Keyboard.N:
                    createNewMap();
                    break;
                case Keyboard.Q:
                    drawTectonicPlatesByColor();
                    break;
                case Keyboard.W:
                    drawTectonicPlatesByType();
                    break;
                case Keyboard.E:
                    drawHeightMap();
                    break;
                default:
                    break;
            }
        }

        private function onClick(event:MouseEvent):void {
            layer1.graphics.clear();
            var p:Point = new Point(event.localX, event.localY);
            var size:int = 40;
            var range:Rectangle = new Rectangle(p.x - size / 2, p.y - size / 2, size, size);
            var cell:Cell = map.getCellByPoint(Util.closestPoint(p, map.quadTree.query(range)));

            var str:String = "Cell " + cell.index;
            for each (var neighbor:Cell in cell.neighbors) {
                if (cell.tectonicPlate != neighbor.tectonicPlate) {
                    var edge:Edge = cell.sharedEdge(neighbor);
                    if (edge) {
                        var edgeAngle:int = Util.angleBetweenTwoPoints(edge.d0.point, edge.d1.point);
                        var angleToEdge:int = Util.angleBetweenTwoPoints(cell.point, neighbor.point);
                        var difference:int = Util.differenceBetweenTwoDegrees(edgeAngle, angleToEdge);
                        str += "\nEdge (" + edge.d0.point.x + "," + edge.d0.point.y + "),(" + edge.d1.point.x + "," + edge.d1.point.y + ")";
                        str += "\nedgeAngle=" + edgeAngle + " ### angleToEdge=" + angleToEdge + " ### difference=" + difference;
                    }
                }
            }

            trace(str);
        }

        private function createNewMap():void {
            var d:Date = new Date();
            map = new Map(1600, 1000, seed++);

            lithosphere = new Lithosphere(map);
            drawTectonicPlatesByColor();
            Util.log("Total time taken: " + "  " + Util.secondsSince(d));
        }

        private function drawHeightMap():void {
            var g:Graphics = layer0.graphics;
            g.clear();

            for each (var cell:Cell in map.cells)
                fillCell(g, cell, Util.colorBetweenColors(Color.blue, Color.green, cell.height));
        }

        private function drawTectonicPlatesByColor():void {
            var g:Graphics = layer0.graphics;
            g.clear();

            for each (var cell:Cell in map.cells) {
                if (cell.tectonicPlate)
                    fillCell(g, cell, cell.tectonicPlate.color);

                for each (var edge:Edge in cell.edges)
                    if (edge.v0 && edge.v1)
                        drawLine(g, edge.v0.point, edge.v1.point, Color.black);

                // Draw tectonic plate direction
                if (cell.tectonicPlateBorder)
                    drawPointer(g, cell.point, cell.tectonicPlateDirection);
            }
        }

        private function drawTectonicPlatesByType():void {
            var g:Graphics = layer0.graphics;
            g.clear();

            for each (var cell:Cell in map.cells) {
                if (cell.tectonicPlate)
                    fillCell(g, cell, cell.tectonicPlate.type == TectonicPlate.OCEANIC ? Color.blue : Color.green);

                for each (var edge:Edge in cell.edges)
                    if (edge.v0 && edge.v1)
                        drawLine(g, edge.v0.point, edge.v1.point, Color.black);

                // Draw tectonic plate direction
                drawPointer(g, cell.point, cell.tectonicPlateDirection);
            }
        }

        private function fillCell(g:Graphics, cell:Cell, color:uint):void {
            // Draw a filled cell
            g.beginFill(color);
            for each (var edge:Edge in cell.edges) {
                if (edge.v0 && edge.v1) {
                    g.moveTo(edge.v0.point.x, edge.v0.point.y);
                    g.lineTo(cell.point.x, cell.point.y);
                    g.lineTo(edge.v1.point.x, edge.v1.point.y);
                }
            }
            g.endFill();
        }

        private function drawDot(g:Graphics, point:Point, color:uint, size:int):void {
            g.beginFill(color);
            g.drawCircle(point.x, point.y, size);
            g.endFill();
        }

        private function drawLine(g:Graphics, point1:Point, point2:Point, color:uint, weight:Number = 1):void {
            g.lineStyle(weight, color);
            g.moveTo(point1.x, point1.y);
            g.lineTo(point2.x, point2.y);
            g.lineStyle();
        }

        private function drawPointer(g:Graphics, point:Point, direction:Number):void {
            // Draw pointer
            var head:Point = Util.pointFromAngleAndDistance(point, Util.degreesToRadians(direction - 90), 6);
            g.lineStyle(1, Color.black);
            g.beginFill(Color.white);
            g.drawCircle(point.x, point.y, 4);
            g.endFill();
            g.moveTo(point.x, point.y);
            g.lineTo(head.x, head.y);
            g.lineStyle();
        }
        ]]>
    </fx:Script>
</s:Application>